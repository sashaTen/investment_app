*essential core APIs of MLflow Tracking:
logging, registering, and loading of a model for inference.

*you can    log   hyperparams  and   loss  metrics .

* also   you can  save the  vectoriaer  for  text  preproccessing  

* you  need  to  look  up  what  is   important  to log 
in order  to recreate  the   experements 

* you  can   just   download the  model  and    artifacts and then 
just  use   paths   to  your  local  machine   for  reference   

* Tuple[pd.Series, pd.Series, pd.Series, pd.Series]   is   
X_train, X_test, y_train, y_test

*  what   you  return  is  the   output
in the  zen ml  server 

*then   you   train  the   pipeline  and 
you can  use  the models    by loading  in  similar    
way  you do  with   mlflow : 
 vectorizer_artifact = Client().get_artifact_version('ae428915-e9f8-46ad-80a3-f223ebb4e6ce')
    vectorizer = vectorizer_artifact.load()

    model_artifact = Client().get_artifact_version('6a4a2d3b-8ba9-4248-9c4e-752080717532')
    model = model_artifact.load()
    sentiment = request.POST['sentiment']
    sentiment =  [sentiment]
    sentiment_vectorized = vectorizer.transform(sentiment)
    prediction = model.predict(sentiment_vectorized)


below  is the  practice   inspiration  
for the   zenml and  mlflow 


1. Focus and Purpose
ZenML: Primarily designed for creating reproducible, scalable, and robust ML pipelines. It emphasizes pipeline orchestration and integration with various tools and environments.
MLflow: A comprehensive tool for managing the entire machine learning lifecycle, including experiment tracking, model versioning, and deployment.
2. Experiment Tracking
ZenML: Provides basic experiment tracking through its pipeline components but may not have as rich a set of features as MLflow specifically for tracking and visualizing experiments.
MLflow: Offers a robust experiment tracking interface, allowing you to log metrics, parameters, and artifacts easily, with an intuitive UI for comparison.
3. Model Registry
ZenML: Focuses on building and managing pipelines rather than serving as a model registry.
MLflow: Includes a dedicated model registry where you can manage model versions, track lineage, and deploy models seamlessly.
4. Integration Flexibility
ZenML: Aims to integrate various tools in the ML ecosystem, providing a standardized way to work with different libraries and frameworks.
MLflow: Works well as a standalone tool for tracking and managing models, and it can be integrated into ZenML pipelines as needed.
5. Deployment Features
ZenML: Supports the orchestration of deployment workflows but may not provide the same depth of deployment capabilities as MLflow.
MLflow: Offers model serving capabilities, allowing you to deploy models as REST APIs easily.
6. Collaboration and Sharing
ZenML: Focuses on the development of reproducible workflows, which helps teams collaborate on pipeline development.
MLflow: Facilitates collaboration through experiment tracking and model sharing, making it easy for teams to work with the same models and results.
Conclusion
Using both ZenML and MLflow can provide a comprehensive solution for managing machine learning workflows. ZenML excels at building and orchestrating pipelines, while MLflow offers specialized tools for experiment tracking, model management, and deployment. By integrating both tools, you can enhance your machine learning projectâ€™s scalability, reproducibility, and efficiency, ensuring a smoother workflow from development to production.
